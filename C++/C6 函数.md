# C6 函数

## 6.1 函数的定义

函数由函数名以及一组操作数类型唯一地表示。函数的操作数，也即形参，在一 对圆括号中声明，形参与形参之间以逗号分隔。函数执行的运算在一个称为函数 体的块语句中定义。每一个函数都有一个相关联的返回类型。 

```c++
 // return the greatest common divisor
 int gcd(int v1, int v2)
 {
 while (v2) {
 int temp = v2;
 v2 = v1 % v2;
 v1 = temp;
 }
 return v1;
 } 
```

函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或指 向数组元素的指针的指针

形参表由一系列用逗号分隔的参数类型和（可选的）参数名组成。如果两个参数具有相同的类型，则其类型必须重复声明：

```c++
int manip(int v1, v2) { /* ... */ } // error 
int manip(int v1, int v2) { /* ... */ } // ok 
```

## 6.2 参数传递

**非引用形参**

普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初 始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。

指针形参：

函数的形参可以是指针，此时将复制实参指针。与其他非引用类型的形参一样，该类形参的任何改变也仅作用于局部副本。如果函数将新指 针赋给形参，主调函数使用的实参指针的值没有改变。 

const 形参:

调用函数时，如果该函数使用非引用的非 const 形参，则既可给该函数 传递 const 实参也可传递非 const 的实参。例如，可以传递两个 int 型 const 对象调用 gcd

**引用形参**

与所有引用一样，引用形参直接关联到其所绑定的圣贤，而并非这些对象的 副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以 相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。

**数组形参**

数组有两个特殊的性质，影响我们定义和使用作用在数组上的函数：一是不 能复制数组；二是使用数组名字时，数组名会自动转化为指向 其第一个元素的指针。因为数组不能复制，所以无法编写使用 数组类型形参的函数。因为数组会被自动转化为指针，所以处理数组的函数通常 通过操纵指向数组指向数组中的元素的指针来处理数组。 

可用下面三种方式指定数 组形参： 

```c++
 // three equivalent definitions of printValues
 void printValues(int*) { /* ... */ }
 void printValues(int[]) { /* ... */ }
 void printValues(int[10]) { /* ... */ } 
```

和其他类型一样，数组形参可声明为数组的引用。如果形参是数组的引用， 编译器不会将数组实参转化为指针，而是传递数组的引用本身。在这种情况下， 数组大小成为形参和实参类型的一部分。编译器检查数组的实参的大小与形参的 大小是否匹配



和其他数组一样，多维数组以指向 0 号元素的指针方式传递。多维数组的 元素本身就是数组。除了第一维以外的所有维的长度都是元素类型的一部分，必须明确指定

```c++
 // first parameter is an array whose elements are arrays of 10 ints
 void printValues(int (matrix*)[10], int rowSize); 
```

```c++
 int *matrix[10]; // array of 10 pointers
 int (*matrix)[10]; // pointer to an array of 10 ints 
```

数组语法定义多维数组

```c++
 // first parameter is an array whose elements are arrays of 10 ints
 void printValues(int matrix[][10], int rowSize); 
```

**可变形参**

在无法列举出传递给函数的所有实参的类型和数目时，可以使用省略符形 参。省略符暂停了类型检查机制。它们的出现告知编译器，当调用函数时，可以 有 0 或多个实参，而实参的类型未知。省略符形参有下列两种形式： 

```c++
 void foo(parm_list, ...);
 void foo(...); 
```

## 6.3 Return

​		理解返回引用至关重要的是：千万不能返回局部变量的引用。 当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象 的引用就会指向不确定的内存。返回指向局部对象的指针也是错误的。一旦函数结束， 局部对象被释放，返回的指针就变成了指向不再存在的对象的悬垂指针。

## 6.4 内联函数

将函数指定为 inline 函数，（通常）就是将它在程序中每个调用点上“内联地” 展开。假设我们将 shorterString 定义为内联函数，则调用： 

```c++
cout << shorterString(s1, s2) << endl;
```

在编译时将展开为： 

```c++
cout << (s1.size() < s2.size() ? s1 : s2)<< endl; 
```

一般来说，内联机制适用于优化小的、只有几行的而且经常被调用的函数。 大多数的编译器都不支持递归函数的内联。一个 1200 行的函数也不太可能在调用点内联展开。

内联函数应该在头文件中定义，这一点不同于其他函数。

## 6.5 类的成员函数

每个成员函数（除了 static 成员函数外）都有一个额外的、隐含的形参 this。在调用成员函数时，形参 this 初始化为调用函数的对象的 地址。在成员函数中，不必显式地使用 this 指针来访问被调用函数所属对象的成员。 对这个类的成员的任何没有前缀的引用，都被假定为通过指针 this 实现的引用： 

```c++
 bool same_isbn(const Sales_item &rhs) const
 { return isbn == rhs.isbn; } 
```

由编译器创建的默认构造函数通常称为默认构造函数，它将依据如同变量初始化的规则初始化类中所有成员。

内置类型成员的初值依 赖于对象如何定义。如果对象在全局作用域中定义（即不在任何函数中）或定义 为静态局部对象，则这些成员将被初始化为 0。如果对象在局部作用域中定义， 则这些成员没有初始化。除了给它们赋值之外，出于其他任何目的对未初始化成 员的使用都没有定义。 

**类代码文件的组织**

通常将类的声明放置在头文件中。大多数情况下，在 类外定义的成员函数则置于源文件中。C++ 程序员习惯使用一些简单的规则给头 文件及其关联的类定义代码命名。类定义应置于名为 type.h 或 type.H 的文件 中，type 指在该文件中定义的类的名字。成员函数的定义则一般存储在与类同名的源文件中。

## 6.6 重载函数

出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。

```c++
 Record lookup(const Account&); // find by Account
 Record lookup(const Phone&); // find by Phone
 Record lookup(const Name&); // find by Name
 Record r1, r2;
 r1 = lookup(acct); // call version that takes an Account
 r2 = lookup(phone); // call version that takes a Phone 
```

 这里的三个函数共享同一个函数名，但却是三个不同的函数。编译器将根据所传 递的实参类型来判断调用的是哪个函数。

如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一 个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。

一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数 将屏蔽而不是重载在外层作用域中声明的同名函数。

**函数匹配与实参转换**

函数重载确定，即函数匹配是将函数调用与重载函数集合中的一个函数相关联的 过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形 参做比较，编译器实现该调用与函数的匹配。匹配结果有三种可能： 

1.编译器找到与实参最佳匹配的函数，并生成调用该函数的代码。

2.找不到形参与函数调用的实参匹配的函数，在这种情况下，编译器将给出编译错误信息。 

3.存在多个与实参匹配的函数，但没有一个是明显的最佳选择。这种情况也是，该调用具有二义性。

**重载确定的三个步骤**

**1.候选函数**

第一步是确定该调用所考虑的重载函数集合，该集合中的函数称 为候选函数。候选函数是与被调函数同名的函数，并且在调用点上，它的声明可见。

**2.选择可行函数**

第二步是从候选函数中选择一个或多个函数，它们能够用该调用中指定的实参来 调用。因此，选出来的函数称为可行函数。可行函数必须满足两个条件：第一， 函数的形参个数与该调用的实参个数相同；第二，每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型。（如果函数具有默认实参，则调用该函数时，所用的实参可能比实际需要的少。默认实参也是实参，在函数匹配过程中，它的处理方式与其他实参一样）

**3.寻找最佳匹配**

函数重载确定的第三步是确定与函数调用中使用的实际参数匹配最佳的可行函 数。这个过程考虑函数调用中的每一个实参，选择对应形参与之最匹配的一个或 多个可行函数。这里所谓“最佳”的细节将在下一节中解释，其原则是实参类型 与形参类型越接近则匹配越佳。因此，实参类型与形参类型之间的精确类型匹配 比需要转换的匹配好。 



**实参类型转换**

为了确定最佳匹配，编译器将实参类型到相应形参类型转换划分等级。转换等级以降序排列如下： 

1.精确匹配。实参与形参类型相同。 

2.通过类型提升实现的匹配（5.12.2 ）。 

3.通过标准转换实现的匹配（5.12.3 ）。 

4.通过类类型转换实现的匹配（14.9 ）。 

## 6.7 指向函数的指针

函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也 指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关：

```c++
 // pf points to function returning bool that takes two const string references
 bool (*pf)(const string &, const string &); 
 
 // declares a function named pf that returns a bool*
 bool *pf(const string &, const string &); 
```

这个语句将 pf 声明为指向函数的指针，它所指向的函数带有两个 const string& 类型的形参和 bool 类型的返回值。 (*pf 两侧的圆括号是必需的)

在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。

指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数。函数的形参可以是指向函数的指针。

**返回指向函数的指针**

函数可以返回指向函数的指针：

```c++
 // ff is a function taking an int and returning a function pointer
 // the function pointed to returns an int and takes an int* and an int
 int (*ff(int))(int*, int); 
 //阅读函数指针声明的最佳方法是从声明的名字开始由里而外理解。 
```

要理解该声明的含义，首先观察 

```c++
ff(int)
```

将 ff 声明为一个函数，它带有一个 int 型的形参。该函数返回 

```c++
int (*)(int*, int); 
```

它是一个指向函数的指针，所指向的函数返回 int 型并带有两个分别是 int* 型和 int 型的形参。 

使用 typedef

```c++
 // PF is a pointer to a function returning an int, taking an int* and an int
 typedef int (*PF)(int*, int);
 PF ff(int); // ff returns a pointer to function
```

允许将形参定义为函数类型，但函数的返回类型则必须是指向 函数的指针，而不能是函数。 

**指向重载函数的指针**

C++ 语言允许使用函数指针指向重载的函数，指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误。
