# C7 类

## 7.1 类的定义和声明

Sale_item类示例：

```c++
class Sales_item {
public:
 // operations on Sales_item objects
 double avg_price() const;
 bool same_isbn(const Sales_item &rhs) const
 { return isbn == rhs.isbn; }
 // default constructor needed to initialize members of built-in type
 Sales_item(): units_sold(0), revenue(0.0) { }
private:
 std::string isbn;
 unsigned units_sold;
 double revenue;
};
double Sales_item::avg_price() const
{
 if (units_sold) 
     return revenue/units_sold;
 else
 return 0;
}
```

### 7.1.1 数据抽象和封装

类背后蕴涵的基本思想是数据抽象和封装。 

​        数据抽象是一种依赖于接口和实现分离的编程（和设计）技术。类设计者必 须关心类是如何实现的，但使用该类的程序员不必了解这些细节。相反，使用一 个类型的程序员仅需了解类型的接口，他们可以抽象地考虑该类型做什么，而不必具体地考虑该类型如何工作。 

​        封装是一项低层次的元素组合起来的形成新的、高层次实体珠技术。函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。 被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执 行的语句。同样地，类也是一个封装的实体：它代表若干成员的聚焦，大多数（良 好设计的）类类型隐藏了实现该类型的成员。 

​	   标准库类型 vector 同时具备数据抽象和封装的特性。在使用方面它是抽象 的，只需考虑它的接口，即它能执行的操作。它又是封装的，因为我们既无法了 解该类型如何表示的细节，也无法访问其任意的实现制品。另一方面，数组在概 念上类似于 vector，但既不是抽象的，也不是封装的。可以通过访问存放数组 的内存来直接操纵数组。 

​        程序的所有部分都可以访问带有 public 标号的成员。类型的数据抽象视 图由其 public 成员定义。 • 使用类的代码不可以访问带有 private 标号的成员。private 封装了类型的实现细节

数据抽象和封装提供了两个重要优点：

 • 避免类内部出现无意的、可能破坏对象状态的用户级错误。

 • 随时间推移可以根据需求改变或缺陷（bug）报告来完美类实现， 而无须改变用户级代码。 

### 7.1.2 类对象

​		定义一个类时，也就是定义了一个类型。一旦定义了类，就可以定义该类型 的对象。定义对象时，将为其分配存储空间，但（一般而言）定义类型时不进行存储分配。

​		定义一个新的类型不进行存储分配。当我们定义一个对象 时，

```
Sales_item item;
```

​		编译器分配了足以容纳一个 Sales_item 对象的存储空间。item 指的就是那个存储空间。每个对象具有自己的类数据成员的副本。修改 item 的数据 成员不会改变任何其他 Sales_item 对象的数据成员。 

## 7.2 隐含的this指针

**1.何时使用**

当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最 常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。 

**2.从 const 成员函数返回 *this **

在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针（4.2.5 ）。可以改变 this 所指向的值，但不能改变 this 所保存 的地址。在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。（不能从 const 成员函数返回指向类对象的普通引用，const 成员函数只能返回 *this 作为一个 const 引用）

**3.可变数据成员**

将它们声明为 mutable ，可以实现类的数据成员（甚至在 const 成员函数内）的修改。

可变数据成员（mutable data member）永远都不能为 const，甚至当它是 const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。

## 7.3 类作用域

##### **名字查找**（寻找与给定的名字使用相匹配的声明的过程）

1.首先，在使用该名字的块中查找名字的声明。只考虑在该项使用之前声明 的名字。 

2.如果找不到该名字，则在包围的作用域中查找。



可能引起混淆的是函数中名字确定的方式，而该函数是在类定义体内定义的。

类定义实际上是在两个阶段中处理： 

1.首先，编译成员声明；

2.只有在所有成员出现之后，才编译它们的定义本身。 

**类成员声明的名字查找** 

1.检查出现在名字使用之前的类成员的声明。 

2.如果第 1 步查找不成功，则检查包含类定义的作用域中出现的声明以及出现在类定义之前的声明。 

**类成员定义中的名字查找**

1.首先检查成员函数局部作用域中的声明。

2.如果在成员函数中找不到该名字的声明，则检查对所有类成员的声明。 

3.如果在类中找不到该名字的声明，则检查在此成员函数定义之前的作用域中出现的声明。

接着，类成员遵循常规的块作用域名字查找。函数作用域之后，在类作用域中查找 。类作用域之后，在外围作用域中查找。在文件中名字的出现处确定名字。

## 7.4 构造函数

构造函数的名字与类的名字相同，并且不能指定返回类型。像其他任何函数一样，它们可以没有形参，也可以定义多个形参。 

##### **构造函数初始化列表**

```c++
 // recommended way to write constructors using a constructor initializer
 Sales_item::Sales_item(const string &book):
 isbn(book), units_sold(0), revenue(0.0) { } 
```

构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。这个构造函数将 isbn 成员初始化为 book 形参的值，将 units_sold 和 revenue 初始化为 0。与任意的成员函数一样，构造函数可以定义在类的内部或外部。构造函数初始化只在构造函数的定义中而不是声明中指定。 



```c++
 // legal but sloppier way to write the constructor:
 // no constructor initializer
 Sales_item::Sales_item(const string &book)
 {
 isbn = book;
 units_sold = 0;
 revenue = 0.0;
 }
```

**注意：**这个构造函数给类 Sales_item 的成员赋值，但没有进行显式初始化。不管是否有显式的初始化式，在执行构造函数之前，要初始化 isbn 成员。这个构造函数隐式使用默认的 string 构造函数来初始化 isbn。执行构造函数的函数体时，isbn 成员已经有值了。该值被构造函数函数体中的赋值所覆盖。

从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2） 普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 

如果没有为类成员提供初始化式，则编译器会隐式地使用成员类型的默认构造函数。 （有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不 管是哪种类型，都必须在构造函数初始化列表中进行初始化。 ）

##### 默认构造函数

**合成的默认构造函数**（synthesized default constructor）使用与变量初 始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数 来进行初始化。内置和复合类型的成员，如指针和数组，只对定义在全局作用域 中的对象才初始化。当对象定义在局部作用域中时，内置或复合类型的成员不进行初始化。

（如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数。它应该定义自己的构造函数来初始化这些成员）

##### 隐式类类型转换

**抑制由构造函数定义的隐式转换 **

可以通过将构造函数声明为 explicit，来防止在需要隐式转换的上下文中使用构造函数： 

```c++
 class Sales_item {
 public:
 // default argument for book is the empty string
 explicit Sales_item(const std::string &book = ""):
 isbn(book), units_sold(0), revenue(0.0) { }
 explicit Sales_item(std::istream &is);
 // as before
 }; 
```

**为转换而显式地使用构造函数 **

只要显式地按下面这样做，就可以用显式的构造函数来生成转换： 

```c++
 string null_book = "9-999-99999-9";
 // ok: builds a Sales_itemwith 0 units_soldand revenue from
 // and isbn equal to null_book
 item.same_isbn(Sales_item(null_book));
```



## 7.5 友元

友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现 在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受声明 出现部分的访问控制影响。 

为了正确地构造类，需要注意友元声明与友元定义之间的互相依赖。必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。 （友元声明将已命名的类或非成员函数引入到外围作用域中。此外，友元函数可以在类的内部定义，该函数的作用域扩展到包围该类定义的作用域）

## 7.6 static 类成员 

全局对象会破坏封装：对象需要支持特定类抽象的实现。如果对象是全局的，一般的用户代码就可以修改这个值。类可以定义类静态成员，而不是定义一个可普遍访问的全局对象。

static 数据成员独立于该类的任意对象而存在；每个 static 数据成员是与类关联的对象，并不与该类的对象相关联。

static 成员函数没有 this 形参，它可以直接访问所属类的 static 成员，但不能直接使用非 static 成员。因为 static 成员不是任何对象的组成部分，所以 static 成员函数不能被声明为 const。毕竟，将成员函数声明为 const 就是承诺不会修改该函数所属的对象。最后，static 成员函数也不能被声明为虚函数。

**使用类的 static 成员的优点 **

1.static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或 全局对象名字冲突。

2.可以实施封装。static 成员可以是私有成员，而全局对象不可以。 

3.通过阅读程序容易看出 static 成员是与特定类关联的。这种可见性可清晰地显示程序员的意图。

**static 数据成员**

一般而言，类的 static 成员，像普通数据成员一样，不能在类的定义体中初始化。相反的是，static 数据成员通常在定义时才初始化。

这个规则的一个例外是，只要初始化式是一个常量表达式，整型 const static 数据成员就可以在类的定义体中进行初始化：

```c++
 class Account {
 public:
 static double rate() { return interestRate; }
 static void rate(double); // sets a new rate
 private:
 static const int period = 30; // interest posted every 30 days
 double daily_tbl[period]; // ok: period is constant expression
 }; 

```



