# C2 变量和基本类型

## 2.1基本内置类型

![](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282223625.png)

**1.整型**

char ,unsigned char ,signed char

**2.浮点型**

## 2.2字面值常量

​		像 42 这样的值，在程序中被当作字面值常量。称之为字面值是因为只能用 它的值称呼它，称之为常量是因为它的值不能修改。每个字 面值都有相应的类型， 例如：0 是 int 型，3.14159 是 double 型。只有内置类型存在字面值，没有类类型的字面值。因此，也没有任何标准库类型的字面值。

**1.整型**

![2](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226113.png)

![3](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226377.png)

**2.浮点**

**3.布尔，字符**

**4.转义**

![4](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226800.png)

**5.字符串连接**

两个相邻的仅由空格、制表符或换行符分开的字符串字面值（或宽字符串字 面值），可连接成一个新字符串字面值。这使得多行书写长字符串字面值变得简单：

```c++
 // concatenated long string literal std::cout << "a multi-line "

												 "string literal " 

												"using concatenation" 65 

												<< std::endl; 
```



执行这条语句将会输出： a multi-line string literal using concatenation 

如果连接字符串字面值和宽字符串字面值，将会出现什么结果呢？例如：

```c++
std::cout << "multi-line " L"literal " << std::endl；
```

其结果是未定义的，也就是说，连接不同类型的行为标准没有定义。这个程序可能会执行，也可能会崩溃或者产生没有用的值，而且在不同的编译器下程序 的动作可能不同。

**6.多行字面值**

![5](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226257.png)

注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后 继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串 字面值的后继行才不会有正常的缩进。

## 2.3 变量

**1.区分左值右值**

![6](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226594.png)

**左值理解成地址，右值理解成地址所指内容**

**2.变量名**

标识符：字母、数字（不能开头）、下划线

**3.关键字和操作符替代名**

​																											**关键字**

![7](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226916.png)

​																										**替代名**

![8](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226108.png)

**4.初始化**

直接初始化和复制初始化：

```c++
int ival(1024); // direct-initialization
int ival = 1024; // copy-initialization
```

在 C++ 中理解 “初始化不是赋值”是必要的。初始化指创建变量并给它赋初 始值，而赋值则是擦除对象的当前值并用新值代替。 

**5.声明与定义**

![9](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226353.png)

## 2.4const限定符

```c++
const int bufSize = 512; // input buffer size 
```

定义 bufSize 为常量并初始化为 512。变量 bufSize 仍然是一个左值（第 2.3.1 节），但是现在这个左值是不可修改的。任何修改 bufSize 的尝试都会 导致编译错误： 

```c++
bufSize = 0; // error: attempt to write to const object 
```

因为常量在定义后就不能被修改，所以定义时必须初始化：

```c++
const std::string hi = "hello!"; // ok: initialized 

const int i, j = 0; // error: i is uninitialized const 
```

与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义 该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。

## 2.5引用

引用只是绑定对象的别名，const引用只读不可修改，const引用可初始化为不同类型对象或初始化为右值（字面值常量）

![26](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282226731.png)

引用的引用相当于多一个别名（折叠引用）

**右值引用：**

**右值不能取地址，但是给右值引用后，引用的变量是可以取地址的,并且可以修改！**
`右值引用存放的地方在栈的附近。`

```c++
int main()
{
	int&& rra = 10;
	//不想被修改 const int&& rra
	cout << &rra << endl;
	rra = 100;
	return 0;
}

```

**顶层底层const:**

??????????????????????????????????????

**decltype:**

?????????????????????????????????????

## 2.6Typedef

定义类型的同义词

## 2.7枚举

```c++
// shape is 1, sphere is 2, cylinder is 3, polygon is 4
 enum Forms {shape = 1, sphere, cylinder, polygon}; 
```

默认后一个枚举成员比前一个大一

枚举成员本身是常量表达式

每个enum代表一个新类型

## 2.8补充

![10](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202306282225035.png)

